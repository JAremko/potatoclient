(ns proto-explorer.java-class-mapper
  "Generate mapping from protobuf specs to Java class names.
  
  This extracts package and class information from protobuf descriptors
  to create a mapping that can be used at runtime to determine the
  correct Java class for a given command."
  (:require [clojure.string :as str]
            [clojure.java.io :as io]
            [cheshire.core :as json]))

;; =============================================================================
;; Java Class Extraction
;; =============================================================================

(defn extract-java-class-info
  "Extract Java class information from a protobuf descriptor file.
  
  Returns a map with:
  - :package - The protobuf package (e.g., 'cmd.RotaryPlatform')
  - :java-package - The Java package if specified
  - :outer-classname - The Java outer classname if specified
  - :message-types - Root message types defined in the file"
  [descriptor]
  (let [files (get descriptor :file [])]
    (for [file files
          :when (str/includes? (get file :name "") "jon_shared")]
      (let [package (get file :package)
            options (get file :options {})
            java-package (get options :javaPackage)
            outer-classname (get options :javaOuterClassname)
            message-types (get file :messageType [])]
        {:proto-file (get file :name)
         :package package
         :java-package java-package
         :outer-classname outer-classname
         :root-messages (for [msg message-types
                              :when (= (get msg :name) "Root")]
                          (get msg :name))}))))

(defn proto-package->domain-keyword
  "Convert a protobuf package to a domain keyword.
  
  Examples:
  - 'cmd.RotaryPlatform' -> :rotary-platform
  - 'cmd.CV' -> :cv
  - 'cmd.DayCamera' -> :day-camera
  - 'cmd.Lrf_calib' -> :lrf-calib"
  [package]
  (when (and package (not= package ""))
    (let [parts (str/split package #"\.")
          domain-part (last parts)]
      (-> domain-part
          ;; Replace underscores with hyphens
          (str/replace "_" "-")
          ;; Insert hyphen between lowercase and uppercase letters
          (str/replace #"([a-z])([A-Z])" "$1-$2")
          (str/lower-case)
          (keyword)))))

(defn infer-java-class
  "Infer the Java class name from descriptor info.
  
  The pattern is:
  - Package: cmd.RotaryPlatform
  - Default outer class: JonSharedCmdRotary (based on proto filename)
  - Root message: Root
  - Result: cmd.RotaryPlatform.JonSharedCmdRotary$Root"
  [{:keys [proto-file package outer-classname root-messages]}]
  (when (and package (seq root-messages))
    (let [;; If no outer classname specified, derive from proto filename
          default-outer (when proto-file
                          ;; Convert jon_shared_cmd_rotary.proto -> JonSharedCmdRotary
                          (-> proto-file
                              (str/replace #"\.proto$" "")
                              (str/split #"_")
                              (->> (map str/capitalize)
                                   (str/join))))
          outer (or outer-classname default-outer)
          ;; For now, assume Root message
          inner "Root"]
      (str package "." outer "$" inner))))

;; =============================================================================
;; Mapping Generation
;; =============================================================================

(defn generate-domain-mapping
  "Generate mapping from domain keywords to Java classes.
  
  Reads all JSON descriptors and extracts the mapping."
  [descriptor-dir]
  (let [files (file-seq (io/file descriptor-dir))
        json-files (filter #(str/ends-with? (.getName %) ".json") files)
        descriptors (map #(json/parse-string (slurp %) true) json-files)
        mappings (for [desc descriptors
                       info (extract-java-class-info desc)
                       :when (:package info)]
                   (let [domain (proto-package->domain-keyword (:package info))
                         java-class (infer-java-class info)]
                     (when (and domain java-class)
                       [domain java-class])))]
    (into {} (remove nil? mappings))))

(defn generate-mapping-file
  "Generate a Clojure file with the proto type mapping."
  [descriptor-dir output-file]
  (let [mapping (generate-domain-mapping descriptor-dir)
        ;; Add root-level commands manually
        full-mapping (assoc mapping :root "cmd.JonSharedCmd$Root")]
    (spit output-file
          (str "(ns potatoclient.specs.proto-type-mapping\n"
               "  \"Auto-generated mapping from command domains to Java protobuf classes.\n"
               "  Generated by proto-explorer.\"\n"
               "  (:require [clojure.string :as str]))\n\n"
               "(def domain->proto-type\n"
               "  \"Maps command domain keywords to their protobuf Java class names.\"\n"
               "  " (pr-str full-mapping) ")\n\n"
               "(defn infer-proto-type\n"
               "  \"Infer the protobuf type from command structure.\"\n"
               "  [command]\n"
               "  (let [top-keys (keys command)]\n"
               "    (cond\n"
               "      ;; Root-level commands\n"
               "      (some #{:ping :noop} top-keys) (:root domain->proto-type)\n"
               "      ;; Domain commands\n"
               "      :else (when-let [domain (first (filter domain->proto-type top-keys))]\n"
               "              (get domain->proto-type domain)))))\n"))))

;; =============================================================================
;; Usage
;; =============================================================================

(comment
  ;; Generate the mapping
  (def mapping (generate-domain-mapping "output/json-descriptors"))
  
  ;; See what we got
  (println mapping)
  ;; => {:rotary-platform "cmd.RotaryPlatform.JonSharedCmdRotary$Root"
  ;;     :cv "cmd.CV.JonSharedCmdCv$Root"
  ;;     ...}
  
  ;; Generate the file
  (generate-mapping-file "output/json-descriptors" 
                         "../../shared/specs/protobuf/proto_type_mapping.clj")
  )
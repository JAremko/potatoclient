# Proto Explorer

A Clojure tool for exploring Protocol Buffer schemas through generated Malli specifications, providing validation, search, and documentation capabilities.

## Version 0.5.0

### Overview

Proto Explorer works with protobuf schemas by using JSON descriptors generated by Buf to create comprehensive Malli specifications. This approach provides:
- **Complete schema coverage** without runtime reflection
- **Automatic field name conversion** to Clojure idioms (kebab-case)
- **Full buf.validate constraint support** with CEL expressions preserved
- **Babashka CLI application** for fast spec queries without JVM overhead
- **JSON output format** for easy tool integration
- **Automatic proto type mapping generation** from descriptors
- **Keyword tree generation** for reflection-based protobuf building
- **Constraint-aware test data generation** respecting all buf.validate rules
- **Property-based testing support** with constraint-aware generators
- **Metadata-based architecture** for clean separation of concerns
- **Java reflection features** accessible via JVM uberjar (separate from BB CLI)

## Architecture

The tool follows a JSON-based architecture:
1. **Protogen** generates protobuf classes and JSON descriptors using Buf CLI
2. **Proto Explorer** converts JSON descriptors → EDN → Malli specs
3. **Constraint extraction** attaches buf.validate rules as metadata
4. **Generated specs** are exported to `shared/specs/protobuf/` with constraints applied

### Key Components

```
src/proto_explorer/
├── main.clj                    # CLI entry point for spec generation
├── json_to_edn.clj            # JSON → EDN with kebab-case conversion
├── spec_generator.clj          # EDN → Malli spec generation
├── test_data_generator.clj     # Constraint-aware data generation
├── cli.clj                    # Babashka CLI implementation
├── cli_jvm.clj               # Java reflection features via JVM
├── constraints/               # Constraint handling system
│   ├── compiler.clj           # Multimethod constraint compiler
│   ├── match_compiler.clj     # core.match pattern matching
│   └── metadata_enricher.clj  # Metadata attachment
└── generated_specs.clj         # Runtime spec management
```

## Quick Start

```bash
# Generate protobuf files and JSON descriptors
make proto

# Generate Malli specs from JSON descriptors
make generate-specs

# Use Babashka CLI to explore specs (no JVM startup!)
bb find rotary
bb spec :potatoclient.specs.cmd/ping
bb example :potatoclient.specs.cmd.RotaryPlatform/set-azimuth-value

# Build JVM uberjar for Java reflection features
make uberjar
# Use uberjar for Java class information
java -jar target/proto-explorer-0.1.0.jar java-class Root
```

## Development Workflow: Fuzzy Search → Exact Query

Proto-Explorer follows a two-step workflow: **fuzzy search** to find candidates, then **exact queries** for precise information.

### Step 1: Fuzzy Search (Find Best Matches)

Use fuzzy search when you don't know the exact name or have typos:

```bash
# Find specs with partial/misspelled names
bb find "trak"          # Typo - still finds "track" commands
bb find "start tr"      # Partial - finds "start-track-ndc"
bb find "rotry"         # Misspelled - finds "rotary" commands

# Search is case-insensitive
bb find "CV"            # Same as "cv", "Cv", etc.
bb find "HEATCAMERA"    # Finds heat-camera specs

# Multi-word search
bb find "set velocity"  # Finds all specs with both words
```

**Fuzzy search returns**: A ranked list of specs with their full qualified names.

### Step 2: Exact Query (Get Real Data)

Once you have the exact spec name from fuzzy search, use it to get precise information:

```bash
# Get the exact spec definition
bb spec :potatoclient.specs.cmd.CV/start-track-ndc
# Returns the complete Malli schema with constraints

# Generate valid example data
bb example :potatoclient.specs.cmd.CV/start-track-ndc
# Returns actual data that respects all constraints

# Get Java class information (if needed)
bb java-class StartTrackNDC
bb java-fields StartTrackNDC
```

### Real-World Example: Fixing Kotlin Compilation Errors

```bash
# 1. You see this error:
# error: unresolved reference 'StartTrackNdc'

# 2. Use fuzzy search to find the spec:
bb find "start track"
# Returns:
# {:found 1,
#  :specs [{:spec :potatoclient.specs.cmd.CV/start-track-ndc, ...}]}

# 3. Get exact spec details:
bb spec :potatoclient.specs.cmd.CV/start-track-ndc
# Shows field names and types

# 4. Check Java class name (optional):
bb java-class StartTrackNDC
# Confirms the class uses capital "NDC" not "Ndc"

# 5. Fix your code:
# Change: StartTrackNdc → StartTrackNDC
```

### Why This Two-Step Approach?

1. **Fuzzy search** is forgiving:
   - Handles typos and partial names
   - Case-insensitive
   - Returns multiple candidates
   - Fast (no JVM needed)

2. **Exact queries** provide precision:
   - Complete schema definitions
   - Valid example data
   - Java class details
   - Constraint information

## JSON Output Format

Proto-Explorer outputs JSON by default for easy tool integration. All commands return structured JSON:

```bash
# Find command returns JSON
bb find "rotary"
{
  "found" : 10,
  "specs" : [ {
    "spec" : "potatoclient.specs.cmd.RotaryPlatform/root",
    "namespace" : "potatoclient.specs.cmd.RotaryPlatform",
    "name" : "root"
  }, ... ]
}

# Spec command returns JSON
bb spec :potatoclient.specs.cmd/ping
{
  "spec" : "potatoclient.specs.cmd/ping",
  "definition" : [ "map", { "closed" : true }, ... ]
}

# Example command returns JSON
bb example :potatoclient.specs.cmd/ping
{
  "spec" : "potatoclient.specs.cmd/ping",
  "example" : { }
}

# Stats command returns JSON
bb stats
{
  "total-specs" : 272,
  "total-packages" : 17,
  "by-package" : {
    "potatoclient.specs.cmd.CV" : 23,
    "potatoclient.specs.cmd" : 2,
    ...
  }
}
```

### EDN Output Option

If you prefer EDN output (e.g., for Clojure tooling), use the wrapper script:

```bash
# Use --edn flag for EDN output
./proto-explorer --edn find "rotary"
# Returns EDN format with keywords preserved

# Or explicitly request JSON
./proto-explorer --json find "rotary"
```

## Proto Type Mapping Generation

Proto-Explorer can automatically generate a mapping from command domain keywords to Java protobuf classes:

```bash
# Generate the mapping file
bb generate-proto-mapping
# Creates: shared/specs/protobuf/proto_type_mapping.clj

# With custom paths
bb generate-proto-mapping path/to/descriptors path/to/output.clj
```

This generates a Clojure namespace with the mapping:

```clojure
(ns potatoclient.specs.proto-type-mapping
  "Auto-generated mapping from command domains to Java protobuf classes.")

(def domain->proto-type
  {:rotary-platform "cmd.RotaryPlatform.JonSharedCmdRotary$Root"
   :cv              "cmd.CV.JonSharedCmdCv$Root"
   :compass         "cmd.Compass.JonSharedCmdCompass$Root"
   ...})
```

### Using the Mapping

The mapping helps automatically determine the correct protobuf class from command structure:

```clojure
;; Infer proto type from command
(infer-proto-type {:rotary-platform {:goto {:azimuth 180.0}}})
;; => "cmd.RotaryPlatform.JonSharedCmdRotary$Root"

;; Prepare command with type metadata
(prepare-command {:cv {:start-track-ndc {:x 0.5 :y 0.5}}})
;; => {:type :protobuf-command
;;     :proto-type "cmd.CV.JonSharedCmdCv$Root"
;;     :data {:cv {:start-track-ndc {:x 0.5 :y 0.5}}}}
```

## Keyword Tree Generation

Proto-Explorer generates keyword-based tree structures that map EDN keywords to protobuf Java classes with complete field information. This enables reflection-based protobuf building in Kotlin without manual routing.

### Generating Keyword Trees

```bash
# Generate command tree
bb generate-keyword-tree-cmd
# Creates: shared/specs/protobuf/proto_keyword_tree_cmd.clj

# Generate state tree  
bb generate-keyword-tree-state
# Creates: shared/specs/protobuf/proto_keyword_tree_state.clj

# With custom paths
bb generate-keyword-tree-cmd path/to/descriptors path/to/output.clj
bb generate-keyword-tree-state path/to/descriptors path/to/output.clj
```

### Tree Structure

Each generated tree is a map from keywords to nodes, where each node contains:

```clojure
{:java-class "cmd.System.JonSharedCmdSystem$Root"
 :fields {:start-all {:proto-field "start_all"
                      :setter "setStartAll"
                      :type "TYPE_MESSAGE"
                      :repeated false
                      :oneof-index 0
                      :type-ref ".cmd.System.StartAll"
                      :java-class "cmd.System.JonSharedCmdSystem$StartAll"}
          :stop-all {:proto-field "stop_all"
                     :setter "setStopAll"
                     :type "TYPE_MESSAGE"
                     :repeated false
                     :oneof-index 0
                     :type-ref ".cmd.System.StopAll"
                     :java-class "cmd.System.JonSharedCmdSystem$StopAll"}}
 :children {:start-all {:java-class "cmd.System.JonSharedCmdSystem$StartAll"
                        :fields {}
                        :children {}}
            :stop-all {:java-class "cmd.System.JonSharedCmdSystem$StopAll"
                       :fields {}
                       :children {}}}}
```

### Field Metadata

Each field in the `:fields` map contains:
- `:proto-field` - Original protobuf field name
- `:setter` - Java setter method name (e.g., "setStartAll")
- `:type` - Protobuf type (e.g., "TYPE_MESSAGE", "TYPE_STRING", "TYPE_DOUBLE")
- `:repeated` - Whether it's a repeated field
- `:oneof-index` - Index if field is part of a oneof (0 for first oneof)
- `:type-ref` - For message types, the protobuf type reference
- `:java-class` - For message types, the resolved Java class name

### Command vs State Trees

**Command Tree** (`proto_keyword_tree_cmd.clj`):
- Root class: `cmd.JonSharedCmd$Root`
- Root keywords: `:compass`, `:cv`, `:day-camera`, `:heat-camera`, `:lrf`, `:rotary`, `:system`, etc.
- Used by CommandSubprocess to build protobuf commands from EDN

**State Tree** (`proto_keyword_tree_state.clj`):
- Root class: `ser.JonSharedData$JonGUIState`
- Root keywords: `:system`, `:lrf`, `:camera-day`, `:camera-heat`, `:gps`, `:compass`, etc.
- Used by StateSubprocess to convert protobuf state to Transit maps

### Kotlin Usage Example

```kotlin
fun buildProtobuf(ednData: Map<String, Any>, node: Map<String, Any>): Any {
    val javaClass = Class.forName(node["java-class"] as String)
    val builder = javaClass.getMethod("newBuilder").invoke(null)
    
    val fields = node["fields"] as Map<String, Map<String, Any>>
    
    ednData.forEach { (key, value) ->
        val fieldInfo = fields[key]
        if (fieldInfo != null) {
            val setter = fieldInfo["setter"] as String
            val type = fieldInfo["type"] as String
            
            if (type == "TYPE_MESSAGE") {
                // Recursively build child message
                val childNode = (node["children"] as Map<String, Any>)[key]
                val childProto = buildProtobuf(value as Map<String, Any>, childNode)
                builder.javaClass.getMethod(setter, childProto.javaClass).invoke(builder, childProto)
            } else {
                // Set primitive field
                val setterMethod = builder.javaClass.getMethod(setter, getJavaType(type))
                setterMethod.invoke(builder, value)
            }
        }
    }
    
    return builder.javaClass.getMethod("build").invoke(builder)
}
```

### Benefits

1. **No manual routing**: Automatically handles new commands and state updates
2. **Type-safe**: Full field information with setter methods and types
3. **Reflection-friendly**: All information needed for Kotlin reflection
4. **Static generation**: No runtime overhead in Clojure
5. **Separate trees**: Commands and state are cleanly separated
6. **Supports all features**: Handles oneofs, repeated fields, nested messages

### Common Naming Patterns Found Through This Workflow
- **Acronyms**: Often all caps in Java (`NDC` not `Ndc`, `OSD` not `Osd`)
- **Underscores**: `stop_track` in proto → `StopTrack` in Java
- **Package names**: `cmd.CV` not `cmd.cv`
- **Setter methods**: `setAgc` not `setSetAgc`

## Basic Usage


### Babashka CLI

Proto Explorer includes a lightweight CLI application for spec queries without JVM overhead. The Babashka CLI includes all the fuzzy search improvements using clj-fuzzy for typo-tolerant searches.

```bash
# Find specs with fuzzy matching (case-insensitive, typo-tolerant)
bb find rotary           # Find all specs matching "rotary"
bb find setvel          # Fuzzy matches "set-velocity", "set-value", etc.
bb find "heat agc"      # Multi-word search

# Get spec definition (requires full namespace)
bb spec :potatoclient.specs.cmd/ping
bb spec :potatoclient.specs.cmd.RotaryPlatform/set-mode

# Generate example data
bb example :potatoclient.specs.cmd/ping
# => {:example {}}

# Generate multiple examples
bb examples :potatoclient.specs.cmd.System/set-localization 3

# Show statistics
bb stats

# Batch processing (useful for CI/CD)
echo '[{:op :example :spec :potatoclient.specs.cmd/ping}]' | bb batch
```

#### Java Reflection Features via Babashka

Babashka can now access Java reflection features by calling out to the proto-explorer uberjar. These commands are slower due to JVM startup overhead but provide full Java class information:

```bash
# First, build the uberjar (only needed once)
make uberjar

# Get Java class information (includes :warning in output)
bb java-class Ping
bb java-class cmd.JonSharedCmd\$Root

# Get proto field to Java method mapping
bb java-fields Root
# => {:message "Root",
#     :fields [{:proto-name "protocol_version", :getter "getProtocolVersion", ...}],
#     :warning "This command starts a JVM process and may be slow!"}

# Get Java builder information  
bb java-builder Ping
```

All output is in EDN format with a `:warning` key to indicate JVM usage.

## Java Class Information

Proto Explorer can extract comprehensive Java class information from generated protobuf classes using reflection. These features are accessible through both Babashka CLI (with JVM startup overhead) and the main CLI application.

### CLI Usage

```bash
# Get full Java class info as EDN
make java-class MSG=Root
clojure -M:run java-class Root

# Get proto field mapping
make java-fields MSG=SetAzimuthValue
clojure -M:run java-fields :cmd.RotaryPlatform/set-azimuth-value

# Get builder info
make java-builder MSG=Root

# Get human-readable summary
make java-summary MSG=Root
```

### Information Extracted

- **Class metadata**: Package, name, type (class/interface/enum)
- **Java fields**: Names, types, modifiers (static, final, etc.)
- **Methods**: Names, parameter types, return types
- **Protobuf descriptor**: Field names, numbers, types, JSON names
- **Field accessors**: Mapping of proto fields to getter/setter methods
- **Builder pattern**: Builder class methods for constructing messages
- **Inner classes**: Nested messages and enums

### Example Output

```clojure
{:class {:type :class
         :name "cmd.JonSharedCmd$Root"
         :simple-name "Root"
         :package "cmd"}
 :protobuf-descriptor 
 {:proto-name "Root"
  :fields [{:name "protocol_version" 
            :number 1
            :type "TYPE_INT32"
            :json-name "protocolVersion"
            :getter "getProtocolVersion"}
           {:name "cmd"
            :number 2  
            :type "TYPE_MESSAGE"
            :json-name "cmd"}]}
 :field-accessors
 [{:field-name "protocol_version"
   :field-number 1
   :getter {:name "getProtocolVersion" 
            :return-type {:type :primitive :name "int"}}
   :has-method {:name "hasProtocolVersion"}}]}
```

### Batch Processing

For processing multiple queries efficiently, use batch mode with EDN input:

```bash
# Create an EDN file with queries
cat > queries.edn <<EOF
[{:op :find :pattern "cv"}
 {:op :spec :spec :potatoclient.specs.cmd/ping}
 {:op :example :spec :potatoclient.specs.cmd.CV/start-track-ndc}]
EOF

# Process batch queries
bb batch < queries.edn
```

Output:
```json
{
  "batch-results" : [ {
    "op" : "find",
    "pattern" : "cv",
    "results" : [ "potatoclient.specs.cmd.CV/root", ... ]
  }, {
    "op" : "spec",
    "spec" : "potatoclient.specs.cmd/ping",
    "definition" : [ "map", { "closed" : true } ]
  }, {
    "op" : "example",
    "spec" : "potatoclient.specs.cmd.CV/start-track-ndc",
    "example" : { "channel" : 1, "x" : 0.5, "y" : -0.3 }
  } ]
}
```

## Advanced Features

## Fuzzy Search Features

Proto Explorer uses advanced fuzzy matching algorithms to find specs even with typos or partial names:

### Search Algorithm

The fuzzy search combines multiple algorithms for best results:
- **Jaro-Winkler distance** - Good for typos and character transpositions
- **Levenshtein distance** - Measures edit distance between strings
- **Substring matching** - Bonus for exact substring matches
- **Prefix matching** - Higher score for matching prefixes
- **Case-insensitive** - All searches ignore case

### Search Examples

```bash
# Typo tolerance
bb find rott  # Typo for "root"
# => Finds specs with "root" as best match

# Partial matching
bb find azim
# => Finds all specs with "azimuth" in the name

# Case insensitive
bb find SETVELOCITY
# => Finds :potatoclient.specs.cmd.RotaryPlatform/set-velocity

# Returns top 10 matches sorted by score
bb find set
# => Returns all "set*" specs, best matches first

# Multi-word search
bb find "heat camera"
# => Finds specs matching both "heat" and "camera"
```

### Best Practices

1. **Use fuzzy search to find specs**: `bb find partial-name`
2. **Use exact spec names for queries**: Once you've found the right spec, use its exact name
3. **Java class info works with fuzzy matching**: `bb java-class Root` or `bb java-class ping`



### buf.validate Constraints

Proto Explorer automatically extracts and applies buf.validate constraints:

```bash
# SetAzimuthValue has constraints: value >= 0 && value < 360
bb spec :potatoclient.specs.cmd.RotaryPlatform/set-azimuth-value
# => {:spec :potatoclient.specs.cmd.RotaryPlatform/set-azimuth-value
#     :definition [:map 
#                  [:value [:and [:maybe :double] [:>= 0] [:< 360]]]
#                  [:direction [:and [:maybe :potatoclient.specs.ser/jon-gui-data-rotary-direction]
#                              [:not [:enum 0]]]]]}

# SetElevationValue has constraints: value >= -90 && value <= 90
bb spec :potatoclient.specs.cmd.RotaryPlatform/set-elevation-value
# => {:spec :potatoclient.specs.cmd.RotaryPlatform/set-elevation-value
#     :definition [:map [:value [:and [:maybe :double] [:>= -90] [:<= 90]]]]}

# Generation respects constraints
bb example :potatoclient.specs.cmd.RotaryPlatform/set-azimuth-value
# => {:spec :potatoclient.specs.cmd.RotaryPlatform/set-azimuth-value
#     :example {:value 247.5 :direction 1}}  ; value always between 0-360, direction never 0
```

### Statistics

```bash
# Show statistics about loaded specs
bb stats
# => {:total-specs 272
#     :total-packages 16
#     :by-package {"potatoclient.specs.cmd" 3, "potatoclient.specs.cmd.CV" 9, ...}}
```

## Spec Generation Workflow

### 1. Generate Proto Files and JSON Descriptors

```bash
make proto
```

This runs protogen to:
- Generate Java protobuf classes
- Create JSON FileDescriptorSets with complete schema information
- Output to `output/json-descriptors/`

### 2. Generate Malli Specs

```bash
make generate-specs
# or
clojure -M:run generate-specs --verbose
```

This processes JSON descriptors to create Malli specs with:
- Automatic snake_case → kebab-case conversion
- Proper type mapping (protobuf → Malli)
- Oneof constraint handling with custom `:oneof` schema
- Package-based organization

### 3. Use Generated Specs

The specs are written to `../../shared/specs/protobuf/` and can be used in the main application:

```clojure
(require '[potatoclient.specs.cmd :as cmd])
(require '[potatoclient.specs.cmd.RotaryPlatform :as rotary])

;; Direct spec access
cmd/Root           ; => [:map [:protocol-version [:maybe :int]] ...]
rotary/SetVelocity ; => [:map [:azimuth [:maybe :float]] ...]
```

## Key Components

### JSON to EDN Converter (`json_to_edn.clj`)
- Uses Cheshire for JSON parsing with automatic keywordization
- Converts proto constants (TYPE_STRING → :type-string)
- Handles both snake_case and camelCase to kebab-case

### Spec Generator (`spec_generator.clj`)
- Multimethod-based processing of different field types
- Generates proper Malli schemas with optional field handling
- Creates namespace-organized spec files

### CLI (`cli.clj`)
- Babashka CLI implementation for fast spec queries
- Fuzzy search capabilities using clj-fuzzy
- Example data generation with constraint awareness
- Batch processing support for CI/CD pipelines

### Test Data Generator (`test_data_generator.clj`)
- Generates valid test data respecting all buf.validate constraints
- Supports string constraints (min/max length, patterns, prefix/suffix)
- Supports numeric constraints (gt/gte/lt/lte/const/in/not-in)
- Supports collection constraints (min/max items, uniqueness)
- Property-based testing with `for-all` function

## Architecture Benefits

1. **No Runtime Reflection**: All specs are pre-generated from JSON descriptors
2. **Complete Coverage**: Every message, field, enum, and oneof is captured
3. **Idiomatic Clojure**: Automatic conversion to kebab-case keywords
4. **Validation Ready**: Full Malli integration for validation and generation
5. **Constraint-Aware Generation**: Test data respects all buf.validate rules
6. **Maintainable**: Single source of truth (protobuf files) with automated pipeline
7. **Serializable Specs**: All generated specs can be saved/loaded from disk without errors
8. **Fast CLI Access**: Babashka CLI provides instant spec queries without JVM startup

## Key Features from v0.3.0

### Complete buf.validate Constraint Support
- Extracts all buf.validate annotations from JSON descriptors
- Supports numeric constraints: `gt`, `gte`, `lt`, `lte`, `const`, `in`, `not_in`
- Supports string constraints: `min_len`, `max_len`, `pattern`, `prefix`, `suffix`
- Supports collection constraints: `min_items`, `max_items`, `unique`
- Metadata-based architecture for clean separation of structure and validation

### Constraint-Aware Test Data Generation
- Generates valid test data that respects all constraints
- Property-based testing support with `for-all` function
- Round-trip validation ensures generated data conforms to specs
- No more manual constraint checking in tests

### Improved APIs
- Clean separation: `json->edn` for strings, `load-json-descriptor` for files
- Clear error messages for incorrect usage
- ~95% of generated specs have test coverage

## Testing

The test suite provides comprehensive coverage:
- JSON to EDN conversion with case handling
- Spec generation for all proto constructs
- Constraint compilation and metadata enrichment
- Constraint-aware test data generation
- REPL API functionality
- Integration tests with real protobuf files
- Serialization/deserialization of generated specs

## JVM Uberjar Interface

While the Babashka CLI provides fast spec exploration, the JVM uberjar offers additional Java reflection capabilities:

### Building the Uberjar

```bash
make uberjar
```

### Available Commands

The uberjar provides the following commands:

- `generate-specs` - Generate Malli specs from protobuf descriptors
- `java-class` - Get Java class info for a protobuf message
- `java-fields` - Get proto field to Java method mapping
- `java-builder` - Get Java builder info
- `java-summary` - Get human-readable Java class summary

### Examples

```bash
# Generate specs (same as make generate-specs)
java -jar target/proto-explorer-0.1.0.jar generate-specs -i output/json-descriptors -o ../../shared/specs/protobuf

# Get Java class information
java -jar target/proto-explorer-0.1.0.jar java-class Root

# Get field mappings for a specific class
java -jar target/proto-explorer-0.1.0.jar java-fields cmd.JonSharedCmd\$Root

# Get builder information
java -jar target/proto-explorer-0.1.0.jar java-builder RotaryPlatform.Goto
```

Note: The JVM interface is separate from the Babashka CLI and requires JVM startup time. Use the BB CLI for quick spec exploration and the JVM uberjar for Java reflection features.

## Development

```bash
# Run tests
make test

# Check for compilation issues
make check

# Clean generated files
make clean

# Full rebuild
make clean proto generate-specs
```

## License

Part of the PotatoClient project.
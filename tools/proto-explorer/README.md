# Proto Explorer

A Clojure tool for exploring Protocol Buffer schemas, providing JSON descriptor parsing and documentation capabilities.

## Version 0.5.0

### Overview

Proto Explorer works with protobuf schemas by using JSON descriptors generated by Buf. This approach provides:
- **Complete schema coverage** without runtime reflection
- **Automatic field name conversion** to Clojure idioms (kebab-case)
- **Babashka CLI application** for fast queries without JVM overhead
- **JSON output format** for easy tool integration
- **Automatic proto type mapping generation** from descriptors
- **Keyword tree generation** for reflection-based protobuf building
- **Java reflection features** accessible via JVM uberjar (separate from BB CLI)

## Architecture

The tool follows a JSON-based architecture:
1. **Protogen** generates protobuf classes and JSON descriptors using Buf CLI
2. **Proto Explorer** converts JSON descriptors → EDN for analysis
3. **JSON parsing** provides proto schema information

### Key Components

```
src/proto_explorer/
├── main.clj                  # CLI entry point
├── json_to_edn.clj          # JSON → EDN with kebab-case conversion
├── cli_bb.clj               # Babashka CLI implementation
├── cli_jvm.clj              # Java reflection features via JVM
├── java_class_mapper.clj    # Proto to Java class mapping
├── nested_class_mapper.clj  # Nested message mapping
└── keyword_tree_mapper.clj  # Keyword tree generation
```

## Quick Start

```bash
# Generate protobuf files and JSON descriptors
make proto

# Use Babashka CLI to explore protos (no JVM startup!)
bb find rotary          # Find messages matching "rotary"
bb list cmd             # List all messages in cmd files
bb list                 # List all messages

# Build JVM uberjar for Java reflection features
make uberjar
# Use uberjar for Java class information
java -jar target/proto-explorer-0.1.0.jar java-class Root
```

## Development Workflow: Fuzzy Search → Exact Query

Proto-Explorer follows a two-step workflow: **fuzzy search** to find candidates, then **exact queries** for precise information.

### Step 1: Fuzzy Search (Find Best Matches)

Use fuzzy search when you don't know the exact name or have typos:

```bash
# Find protos with partial/misspelled names
bb find "trak"          # Typo - still finds "track" commands
bb find "start tr"      # Partial - finds "start-track-ndc"
bb find "rotry"         # Misspelled - finds "rotary" commands

# Search is case-insensitive
bb find "CV"            # Same as "cv", "Cv", etc.
bb find "HEATCAMERA"    # Finds heat-camera protos

# Multi-word search
bb find "set velocity"  # Finds all protos with both words
```

**Fuzzy search returns**: A ranked list of protobuf messages.

### Step 2: List Messages

Use the list command to see available messages:

```bash
# List all messages in a package
bb list cmd             # List messages in cmd files
bb list                 # List all messages

# Get Java class information (requires JVM)
bb java-class StartTrackNDC
bb java-fields StartTrackNDC
```

### Real-World Example: Finding Protobuf Messages

```bash
# 1. You need to find a message but unsure of exact name

# 2. Use fuzzy search to find candidates:
bb find "start track"
# Returns matching protobuf messages

# 3. Check Java class information:
bb java-class StartTrackNDC
# Shows Java class details including methods and fields
```

### Why This Two-Step Approach?

1. **Fuzzy search** is forgiving:
   - Handles typos and partial names
   - Case-insensitive
   - Returns multiple candidates
   - Fast (no JVM needed)

2. **Exact queries** provide precision:
   - Complete schema definitions
   - Valid example data
   - Java class details
   - Constraint information

## JSON Output Format

Proto-Explorer outputs JSON by default for easy tool integration. All commands return structured JSON:

```bash
# Find command returns JSON
bb find "rotary"
{
  "found" : 10,
  "messages" : [ {
    "name" : "JonGuiDataRotary",
    "file" : "jon_shared_data_rotary.json",
    "proto-file" : "jon_shared_data_rotary.proto"
  }, ... ]
}

# List command returns JSON
bb list cmd
{
  "total" : 150,
  "messages" : [ {
    "name" : "Root",
    "file" : "jon_shared_cmd.json",
    "proto-file" : "jon_shared_cmd.proto"
  }, ... ]
}
```

### EDN Output Option

If you prefer EDN output (e.g., for Clojure tooling), use the wrapper script:

```bash
# Use --edn flag for EDN output
./proto-explorer --edn find "rotary"
# Returns EDN format with keywords preserved

# Or explicitly request JSON
./proto-explorer --json find "rotary"
```

## Proto Type Mapping Generation

Proto-Explorer can automatically generate a mapping from command domain keywords to Java protobuf classes:

```bash
# Generate the mapping file (requires JVM)
clojure -M:run generate-proto-mapping
# Creates: shared/specs/protobuf/proto_type_mapping.clj

# With custom paths
clojure -M:run generate-proto-mapping path/to/descriptors path/to/output.clj
```

This generates a Clojure namespace with the mapping:

```clojure
(ns potatoclient.specs.proto-type-mapping
  "Auto-generated mapping from command domains to Java protobuf classes.")

(def domain->proto-type
  {:rotary-platform "cmd.RotaryPlatform.JonSharedCmdRotary$Root"
   :cv              "cmd.CV.JonSharedCmdCv$Root"
   :compass         "cmd.Compass.JonSharedCmdCompass$Root"
   ...})
```

### Using the Mapping

The mapping helps automatically determine the correct protobuf class from command structure:

```clojure
;; Infer proto type from command
(infer-proto-type {:rotary-platform {:goto {:azimuth 180.0}}})
;; => "cmd.RotaryPlatform.JonSharedCmdRotary$Root"

;; Prepare command with type metadata
(prepare-command {:cv {:start-track-ndc {:x 0.5 :y 0.5}}})
;; => {:type :protobuf-command
;;     :proto-type "cmd.CV.JonSharedCmdCv$Root"
;;     :data {:cv {:start-track-ndc {:x 0.5 :y 0.5}}}}
```

## Keyword Tree Generation

Proto-Explorer generates keyword-based tree structures that map EDN keywords to protobuf Java classes with complete field information.

### Generating Keyword Trees

```bash
# Generate command tree (requires JVM)
clojure -M:run generate-keyword-tree-cmd
# Creates: shared/specs/protobuf/proto_keyword_tree_cmd.clj

# Generate state tree (requires JVM)
clojure -M:run generate-keyword-tree-state
# Creates: shared/specs/protobuf/proto_keyword_tree_state.clj

# With custom paths
clojure -M:run generate-keyword-tree-cmd path/to/descriptors path/to/output.clj
clojure -M:run generate-keyword-tree-state path/to/descriptors path/to/output.clj
```

### Tree Structure

Each generated tree is a map from keywords to nodes, where each node contains:

```clojure
{:java-class "cmd.System.JonSharedCmdSystem$Root"
 :fields {:start-all {:proto-field "start_all"
                      :setter "setStartAll"
                      :type "TYPE_MESSAGE"
                      :repeated false
                      :oneof-index 0
                      :type-ref ".cmd.System.StartAll"
                      :java-class "cmd.System.JonSharedCmdSystem$StartAll"}
          :stop-all {:proto-field "stop_all"
                     :setter "setStopAll"
                     :type "TYPE_MESSAGE"
                     :repeated false
                     :oneof-index 0
                     :type-ref ".cmd.System.StopAll"
                     :java-class "cmd.System.JonSharedCmdSystem$StopAll"}}
 :children {:start-all {:java-class "cmd.System.JonSharedCmdSystem$StartAll"
                        :fields {}
                        :children {}}
            :stop-all {:java-class "cmd.System.JonSharedCmdSystem$StopAll"
                       :fields {}
                       :children {}}}}
```

### Field Metadata

Each field in the `:fields` map contains:
- `:proto-field` - Original protobuf field name
- `:setter` - Java setter method name (e.g., "setStartAll")
- `:type` - Protobuf type (e.g., "TYPE_MESSAGE", "TYPE_STRING", "TYPE_DOUBLE")
- `:repeated` - Whether it's a repeated field
- `:oneof-index` - Index if field is part of a oneof (0 for first oneof)
- `:type-ref` - For message types, the protobuf type reference
- `:java-class` - For message types, the resolved Java class name

### Command vs State Trees

**Command Tree** (`proto_keyword_tree_cmd.clj`):
- Root class: `cmd.JonSharedCmd$Root`
- Root keywords: `:compass`, `:cv`, `:day-camera`, `:heat-camera`, `:lrf`, `:rotary`, `:system`, etc.

**State Tree** (`proto_keyword_tree_state.clj`):
- Root class: `ser.JonSharedData$JonGUIState`
- Root keywords: `:system`, `:lrf`, `:camera-day`, `:camera-heat`, `:gps`, `:compass`, etc.

### Benefits

1. **Type-safe**: Full field information with setter methods and types
2. **Reflection-friendly**: All information needed for reflection
3. **Static generation**: No runtime overhead
4. **Separate trees**: Commands and state are cleanly separated
5. **Supports all features**: Handles oneofs, repeated fields, nested messages

### Common Naming Patterns Found Through This Workflow
- **Acronyms**: Often all caps in Java (`NDC` not `Ndc`, `OSD` not `Osd`)
- **Underscores**: `stop_track` in proto → `StopTrack` in Java
- **Package names**: `cmd.CV` not `cmd.cv`
- **Setter methods**: `setAgc` not `setSetAgc`

## Basic Usage

### Babashka CLI

Proto Explorer includes a lightweight CLI application for protobuf queries without JVM overhead. The Babashka CLI includes fuzzy search using clj-fuzzy for typo-tolerant searches.

```bash
# Find messages with fuzzy matching (case-insensitive, typo-tolerant)
bb find rotary           # Find all messages matching "rotary"
bb find setvel          # Fuzzy matches "set-velocity", "set-value", etc.
bb find "heat agc"      # Multi-word search

# List messages in a package
bb list cmd
bb list

# Batch processing (useful for CI/CD)
echo '{"type": "find", "pattern": "cv"}' | bb batch
```

#### Java Reflection Features via Babashka

Babashka can now access Java reflection features by calling out to the proto-explorer uberjar. These commands are slower due to JVM startup overhead but provide full Java class information:

```bash
# First, build the uberjar (only needed once)
make uberjar

# Get Java class information (includes :warning in output)
bb java-class Ping
bb java-class cmd.JonSharedCmd\$Root

# Get proto field to Java method mapping
bb java-fields Root
# => {:message "Root",
#     :fields [{:proto-name "protocol_version", :getter "getProtocolVersion", ...}],
#     :warning "This command starts a JVM process and may be slow!"}

# Get Java builder information  
bb java-builder Ping
```

All output is in JSON format with a warning key to indicate JVM usage.

## Java Class Information

Proto Explorer can extract comprehensive Java class information from generated protobuf classes using reflection. These features are accessible through both Babashka CLI (with JVM startup overhead) and the main CLI application.

### CLI Usage

```bash
# Get full Java class info as EDN
make java-class MSG=Root
clojure -M:run java-class Root

# Get proto field mapping
make java-fields MSG=SetAzimuthValue
clojure -M:run java-fields :cmd.RotaryPlatform/set-azimuth-value

# Get builder info
make java-builder MSG=Root

# Get human-readable summary
make java-summary MSG=Root
```

### Information Extracted

- **Class metadata**: Package, name, type (class/interface/enum)
- **Java fields**: Names, types, modifiers (static, final, etc.)
- **Methods**: Names, parameter types, return types
- **Protobuf descriptor**: Field names, numbers, types, JSON names
- **Field accessors**: Mapping of proto fields to getter/setter methods
- **Builder pattern**: Builder class methods for constructing messages
- **Inner classes**: Nested messages and enums

### Example Output

```clojure
{:class {:type :class
         :name "cmd.JonSharedCmd$Root"
         :simple-name "Root"
         :package "cmd"}
 :protobuf-descriptor 
 {:proto-name "Root"
  :fields [{:name "protocol_version" 
            :number 1
            :type "TYPE_INT32"
            :json-name "protocolVersion"
            :getter "getProtocolVersion"}
           {:name "cmd"
            :number 2  
            :type "TYPE_MESSAGE"
            :json-name "cmd"}]}
 :field-accessors
 [{:field-name "protocol_version"
   :field-number 1
   :getter {:name "getProtocolVersion" 
            :return-type {:type :primitive :name "int"}}
   :has-method {:name "hasProtocolVersion"}}]}
```

### Batch Processing

For processing multiple queries efficiently, use batch mode with JSON input:

```bash
# Create a JSON file with queries
cat > queries.json <<EOF
{"type": "find", "pattern": "cv"}
{"type": "list", "package": "cmd"}
EOF

# Process batch queries
bb batch < queries.json
```

## Advanced Features

## Fuzzy Search Features

Proto Explorer uses advanced fuzzy matching algorithms to find messages even with typos or partial names:

### Search Algorithm

The fuzzy search combines multiple algorithms for best results:
- **Jaro-Winkler distance** - Good for typos and character transpositions
- **Levenshtein distance** - Measures edit distance between strings
- **Substring matching** - Bonus for exact substring matches
- **Prefix matching** - Higher score for matching prefixes
- **Case-insensitive** - All searches ignore case

### Search Examples

```bash
# Typo tolerance
bb find rott  # Typo for "root"
# => Finds messages with "root" as best match

# Partial matching
bb find azim
# => Finds all messages with "azimuth" in the name

# Case insensitive
bb find SETVELOCITY
# => Finds SetVelocity messages

# Returns matches sorted by relevance
bb find set
# => Returns all "set*" messages, best matches first

# Multi-word search
bb find "heat camera"
# => Finds messages matching both "heat" and "camera"
```

### Best Practices

1. **Use fuzzy search to find messages**: `bb find partial-name`
2. **Java class info requires exact names**: `bb java-class Root` or `bb java-class Ping`
3. **List messages by package**: `bb list cmd` to see all command messages

## Proto Analysis Workflow

### 1. Generate Proto Files and JSON Descriptors

```bash
make proto
```

This runs protogen to:
- Generate Java protobuf classes
- Create JSON FileDescriptorSets with complete schema information
- Output to `output/json-descriptors/`

### 2. Analyze Proto Messages

```bash
# Find messages
bb find "message-name"

# List all messages
bb list

# Get Java class info
bb java-class MessageName
```

## Key Components

### JSON to EDN Converter (`json_to_edn.clj`)
- Uses Cheshire for JSON parsing with automatic keywordization
- Converts proto constants (TYPE_STRING → :type-string)
- Handles both snake_case and camelCase to kebab-case

### CLI (`cli_bb.clj`)
- Babashka implementation for fast command execution
- Fuzzy search using clj-fuzzy
- JSON output by default for tool integration

### Java Class Mapper (`java_class_mapper.clj`)
- Extracts comprehensive Java class information
- Uses reflection to analyze protobuf generated classes
- Provides proto field → Java method mappings

### Keyword Tree Mapper (`keyword_tree_mapper.clj`)
- Generates keyword-based navigation trees
- Maps EDN keywords to Java protobuf classes
- Includes complete field metadata

## Development

```bash
# Start REPL
make repl

# Run tests
make test

# Build uberjar
make uberjar

# Lint code
make lint
```

## Requirements

- Clojure 1.11+
- Babashka (for CLI features)
- Java 11+ (for reflection features)
- Protobuf compiler (protoc) via protogen

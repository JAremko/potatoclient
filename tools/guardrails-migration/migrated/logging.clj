(ns potatoclient.logging "Centralized logging configuration using Telemere" #:clj-kondo{:config (quote {:linters {:unresolved-var {:exclude [tel/handler:console tel/handler:file tel/format-signal-fn tel/add-handler! tel/remove-handler! tel/set-min-level! tel/set-ns-filter! tel/stop-handlers!]}}})} (:require [clojure.java.io :as io] [clojure.string] [potatoclient.runtime :as runtime] [taoensso.telemere :as tel]) (:import (java.time LocalDateTime) (java.time.format DateTimeFormatter)))

(defn- get-version "Get application version" #:malli{:schema [:=> [:cat] :string]} [] (try (clojure.string/trim (slurp (clojure.java.io/resource "VERSION"))) (catch Exception _ "dev")))

(defn- get-log-dir "Get the log directory path using platform-specific conventions" #:malli{:schema [:=> [:cat] :potatoclient.ui-specs/file]} [] (let [os-name (.toLowerCase (System/getProperty "os.name"))] (cond (.contains os-name "win") (let [local-appdata (System/getenv "LOCALAPPDATA") appdata (System/getenv "APPDATA") user-home (System/getProperty "user.home")] (io/file (or local-appdata appdata (str user-home "/AppData/Local")) "PotatoClient" "logs")) (.contains os-name "mac") (io/file (System/getProperty "user.home") "Library" "Application Support" "PotatoClient" "logs") :else (let [xdg-data (System/getenv "XDG_DATA_HOME") user-home (System/getProperty "user.home") data-base (if (and xdg-data (.startsWith xdg-data "/") (not= xdg-data user-home)) xdg-data (io/file user-home ".local" "share"))] (io/file data-base "potatoclient" "logs")))))

(defn- get-log-file-path "Get the path for the log file with timestamp and version" #:malli{:schema [:=> [:cat] :potatoclient.ui-specs/file]} [] (let [logs-dir (if (runtime/release-build?) (get-log-dir) (io/file "logs")) version (get-version) timestamp (.format (DateTimeFormatter/ofPattern "yyyyMMdd-HHmmss") (LocalDateTime/now)) filename (format "potatoclient-%s-%s.log" version timestamp)] (.mkdirs logs-dir) (io/file logs-dir filename)))

(defn- create-file-handler "Create a file handler for Telemere" #:malli{:schema [:=> [:cat] :fn]} [] (tel/handler:file {:output-fn (tel/format-signal-fn), :path (.getAbsolutePath (get-log-file-path))}))

(defn- cleanup-old-logs! "Keep only the newest N log files, delete older ones" #:malli{:schema [:=> [:cat :pos-int] :nil]} [max-files] (let [log-dir (if (runtime/release-build?) (get-log-dir) (io/file "logs"))] (when (.exists log-dir) (let [log-files (->> (.listFiles log-dir) (filter (fn* [p1__276#] (and (.isFile p1__276#) (clojure.string/ends-with? (.getName p1__276#) ".log") (clojure.string/starts-with? (.getName p1__276#) "potatoclient-")))) (sort-by (fn* [p1__277#] (.lastModified p1__277#)) >)) files-to-delete (drop max-files log-files)] (doseq [file files-to-delete] (try (.delete file) (println (str "Deleted old log file: " (.getName file))) (catch Exception e (println (str "Failed to delete log file: " (.getName file) " - " (.getMessage e))))))))))

(def initialized? (atom false))

(defn init! "Initialize the logging system" #:malli{:schema [:=> [:cat] :nil]} [] (when (compare-and-set! initialized? false true) (cleanup-old-logs! 50) (tel/remove-handler! :default/console) (tel/remove-handler! :default) (tel/remove-handler! :console) (tel/remove-handler! :file) (if (runtime/release-build?) (tel/set-min-level! :warn) (tel/set-min-level! :trace)) (if (runtime/release-build?) (do (tel/add-handler! :console (tel/handler:console {:output-fn (tel/format-signal-fn)}) {:async {:mode :dropping, :buffer-size 1024}, :min-level :warn}) (tel/add-handler! :file (create-file-handler) {:async {:mode :dropping, :buffer-size 1024}, :min-level :warn})) (do (tel/add-handler! :console (tel/handler:console {:output-fn (tel/format-signal-fn)}) {:async {:mode :dropping, :buffer-size 1024}}) (tel/add-handler! :file (create-file-handler) {:async {:mode :dropping, :buffer-size 2048}}))) (tel/set-ns-filter! {:disallow ["com.sun.*" "java.awt.*" "javax.swing.*"]}) (tel/log! {:level :info, :id :user/startup, :data {:build-type (if (runtime/release-build?) "RELEASE" "DEVELOPMENT")}} "PotatoClient logging initialized")) nil)

(defn shutdown! "Shutdown the logging system" #:malli{:schema [:=> [:cat] :nil]} [] (tel/log! {:level :info, :id :user/shutdown} "Shutting down logging system") (tel/stop-handlers!) nil)

(defmacro log-info "Log an info level message." [& args] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/log!)) (clojure.core/list :info) args)))

(defmacro log-debug "Log a debug level message." [& args] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/log!)) (clojure.core/list :debug) args)))

(defmacro log-warn "Log a warning level message." [& args] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/log!)) (clojure.core/list :warn) args)))

(defmacro log-error "Log an error level message." [& args] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/log!)) (clojure.core/list :error) args)))

(defmacro log-event "Log a specific event with id and data." [id data & [msg]] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/event!)) (clojure.core/list id) (clojure.core/list (clojure.core/apply clojure.core/hash-map (clojure.core/seq (clojure.core/concat (clojure.core/list :level) (clojure.core/list :info) (clojure.core/list :data) (clojure.core/list data) (clojure.core/list :msg) (clojure.core/list msg))))))))

(defmacro log-stream-event "Log a stream-specific event." [stream-type event-type data] (clojure.core/seq (clojure.core/concat (clojure.core/list (quote tel/event!)) (clojure.core/list :user/stream-event) (clojure.core/list (clojure.core/apply clojure.core/hash-map (clojure.core/seq (clojure.core/concat (clojure.core/list :level) (clojure.core/list :info) (clojure.core/list :data) (clojure.core/list (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/merge)) (clojure.core/list (clojure.core/apply clojure.core/hash-map (clojure.core/seq (clojure.core/concat (clojure.core/list :stream) (clojure.core/list stream-type) (clojure.core/list :event) (clojure.core/list event-type))))) (clojure.core/list data)))))))))))

(defn get-logs-directory "Get the logs directory path. Public function for UI access." #:malli{:schema [:=> [:cat] :potatoclient.ui-specs/file]} [] (if (runtime/release-build?) (get-log-dir) (io/file "logs")))
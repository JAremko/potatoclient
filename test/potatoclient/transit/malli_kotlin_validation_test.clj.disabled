(ns potatoclient.transit.malli-kotlin-validation-test
  "CRITICAL TEST: Validates that Malli-generated payloads pass Kotlin validation.
  
  This test ensures:
  1. Malli generates valid data according to our specs
  2. Commands built from that data are valid Transit
  3. Kotlin accepts and validates the Transit commands
  4. Protobuf serialization/deserialization works
  5. buf.validate constraints are satisfied
  6. Java representations match (via protobuf equals)"
  (:require [clojure.test :refer [deftest testing is use-fixtures]]
            [malli.core :as m]
            [malli.generator :as mg]
            [potatoclient.transit.commands :as cmd]
            [potatoclient.transit.core :as transit-core]
            ;; TODO: These specs are not on classpath currently
            ;; [potatoclient.specs.cmd :as cmd-specs]
            ;; [potatoclient.specs.cmd.CV :as cv-specs]
            ;; [potatoclient.specs.cmd.RotaryPlatform :as rotary-specs]
            ;; [potatoclient.specs.cmd.DayCamera :as day-specs]
            ;; [potatoclient.specs.cmd.HeatCamera :as heat-specs]
            [clojure.java.shell :as shell]
            [clojure.string :as str]
            [clojure.data.json :as json])
  (:import [java.io File]))

;; =============================================================================
;; Kotlin Integration
;; =============================================================================

(def kotlin-validator-class
  "potatoclient.kotlin.transit.MalliPayloadValidator")

(defn compile-kotlin-validator! []
  "Compile the Kotlin validator if needed"
  (let [result (shell/sh "make" "compile-kotlin-tests"
                         :dir (System/getProperty "user.dir"))]
    (when (not= 0 (:exit result))
      (throw (ex-info "Failed to compile Kotlin tests" result)))))

(defn run-kotlin-validation [command-map]
  "Run command through Kotlin validation and return result"
  ;; First ensure Kotlin is compiled
  (compile-kotlin-validator!)

  ;; Create a temp file with the Transit command
  (let [temp-file (File/createTempFile "malli-test-" ".transit")
        _ (with-open [out (clojure.java.io/output-stream temp-file)]
            (let [writer (transit-core/make-writer out)]
              (transit-core/write-message! writer command-map out)))

        ;; Run Kotlin validator
        result (shell/sh "java" "-cp" "test/kotlin/build/libs/test-all.jar"
                         kotlin-validator-class
                         (.getPath temp-file))]

    ;; Clean up
    (.delete temp-file)

    ;; Parse result
    (if (= 0 (:exit result))
      (json/read-str (:out result) :key-fn keyword)
      {:success false
       :error (str "Kotlin process failed: " (:err result))})))

;; =============================================================================
;; Malli Spec Generators
;; =============================================================================

(defn generate-constrained-samples
  "Generate samples that respect buf.validate constraints"
  [spec n]
  (mg/sample spec {:size n :seed (System/currentTimeMillis)}))

;; =============================================================================
;; Core Validation Tests
;; =============================================================================

(deftest test-rotary-commands-with-malli-generation
  (testing "Rotary commands with Malli-generated values respect constraints"
    ;; Generate valid azimuth/elevation values
    (let [samples (generate-constrained-samples rotary-specs/goto 10)]
      (doseq [sample samples]
        (testing (str "Testing goto with: " sample)
          (let [;; Create command using our API
                command (cmd/rotary-goto (:azimuth sample) (:elevation sample))
                ;; Validate through Kotlin
                result (run-kotlin-validation command)]

            ;; Check success
            (is (:success result)
                (str "Command should validate: " command "\nError: " (:error result)))

            ;; Check constraints were respected
            (when (:success result)
              (let [proto-data (:proto result)]
                (is (<= 0 (:azimuth proto-data) 360))
                (is (<= -30 (:elevation proto-data) 90))))))))))

(deftest test-cv-commands-with-edge-cases
  (testing "CV commands with Malli-generated edge cases"
    ;; Test with explicit edge cases first
    (let [edge-cases [{:channel :heat :x -1.0 :y -1.0}
                      {:channel :heat :x 1.0 :y 1.0}
                      {:channel :heat :x 0.0 :y 0.0}
                      {:channel :day :x -0.999 :y 0.999}]]
      (doseq [params edge-cases]
        (let [command (cmd/cv-start-track-ndc
                        (:channel params)
                        (:x params)
                        (:y params))
              result (run-kotlin-validation command)]
          (is (:success result)
              (str "Edge case should validate: " params)))))

    ;; Now test with generated values
    (let [samples (generate-constrained-samples cv-specs/start-track-ndc 10)]
      (doseq [sample samples]
        (let [command (cmd/cv-start-track-ndc
                        (or (:channel sample) :heat)
                        (:x sample)
                        (:y sample)
                        (:frame-time sample))
              result (run-kotlin-validation command)]
          (is (:success result)))))))

(deftest test-enum-validation-with-generation
  (testing "Enum parameters are correctly validated"
    ;; Test heat camera palettes
    (let [palettes [:white-hot :black-hot :rainbow :ironbow :lava :arctic]]
      (doseq [palette palettes]
        (let [command (cmd/heat-camera-palette palette)
              result (run-kotlin-validation command)]
          (is (:success result)
              (str "Palette " palette " should be valid")))))

    ;; Test with generated enum values
    (let [samples (generate-constrained-samples
                    [:enum :white-hot :black-hot :rainbow :ironbow :lava :arctic]
                    10)]
      (doseq [palette samples]
        (let [command (cmd/heat-camera-palette palette)
              result (run-kotlin-validation command)]
          (is (:success result)))))))

(deftest test-protobuf-equality-after-roundtrip
  (testing "Protobuf equality is maintained through roundtrip"
    (let [test-commands [(cmd/ping)
                         (cmd/rotary-goto 180.0 45.0)
                         (cmd/cv-start-track-ndc :heat 0.5 0.5)
                         (cmd/heat-camera-palette :rainbow)]]

      (doseq [command test-commands]
        (let [;; Send through Kotlin for full roundtrip
              result (run-kotlin-validation command)]

          (when (:success result)
            ;; Kotlin should return both original and roundtripped proto
            (is (= (:original-hash result) (:roundtrip-hash result))
                "Protobuf hash should match after roundtrip")

            ;; Check that extracted Transit matches original structure
            (is (= (keys command) (keys (:extracted result)))
                "Command structure should be preserved")))))))

(deftest test-constraint-violations-detected
  (testing "Invalid values are properly rejected"
    (let [invalid-cases [;; Azimuth > 360
                         #(cmd/rotary-goto 400.0 45.0)
           ;; Elevation < -30  
                         #(cmd/rotary-goto 180.0 -45.0)
           ;; Invalid enum (this should fail at Clojure level with Guardrails)
           ;; #(cmd/heat-camera-palette :invalid-palette)
                         ]]

      (doseq [invalid-fn invalid-cases]
        ;; Some might fail at command creation, others at validation
        (try
          (let [command (invalid-fn)
                result (run-kotlin-validation command)]
            (is (not (:success result))
                "Invalid command should fail validation"))
          (catch Exception e
            ;; This is also acceptable - Guardrails caught it
            (is true "Guardrails validation prevented invalid command")))))))

(deftest test-high-volume-generated-commands
  (testing "High volume test with generated commands"
    (let [;; Generate lots of samples to find edge cases
          goto-samples (generate-constrained-samples rotary-specs/goto 100)
          cv-samples (generate-constrained-samples cv-specs/start-track-ndc 100)

          failures (atom [])]

      ;; Test goto commands
      (doseq [sample goto-samples]
        (let [command (cmd/rotary-goto (:azimuth sample) (:elevation sample))
              result (run-kotlin-validation command)]
          (when-not (:success result)
            (swap! failures conj {:type :goto :sample sample :error (:error result)}))))

      ;; Test CV commands  
      (doseq [sample cv-samples]
        (let [command (cmd/cv-start-track-ndc
                        (or (:channel sample) :heat)
                        (:x sample)
                        (:y sample))
              result (run-kotlin-validation command)]
          (when-not (:success result)
            (swap! failures conj {:type :cv :sample sample :error (:error result)}))))

      ;; Report results
      (let [failure-count (count @failures)]
        (when (pos? failure-count)
          (println "Failures found:" failure-count)
          (doseq [f (take 5 @failures)]
            (println "  " f)))

        (is (zero? failure-count)
            (str failure-count " commands failed validation"))))))

;; =============================================================================
;; Helper to create the Kotlin validator if it doesn't exist
;; =============================================================================

(def kotlin-validator-source
  "package potatoclient.kotlin.transit

import cmd.JonSharedCmd
import com.cognitect.transit.TransitFactory
import com.google.protobuf.util.JsonFormat
import potatoclient.kotlin.transit.generated.GeneratedCommandHandlers
import build.buf.protovalidate.Validator
import java.io.File
import com.google.gson.Gson

/**
 * Validates Malli-generated payloads through the full stack:
 * Transit → Protobuf → Validation → Binary → Protobuf → Transit
 */
object MalliPayloadValidator {
    @JvmStatic
    fun main(args: Array<String>) {
        if (args.isEmpty()) {
            println(\"\"\"
                {\"success\": false, \"error\": \"No input file provided\"}
            \"\"\".trimIndent())
            return
        }
        
        try {
            // Read Transit file
            val transitData = File(args[0]).readBytes()
            val reader = TransitFactory.reader(TransitFactory.Format.MSGPACK, transitData.inputStream())
            val commandMap = reader.read() as Map<*, *>
            
            // Convert to protobuf
            val proto = GeneratedCommandHandlers.buildCommand(commandMap)
                ?: throw Exception(\"Failed to build command from Transit data\")
            
            // Validate with buf.validate
            val validator = Validator.newBuilder().build()
            val validationResult = validator.validate(proto)
            
            if (!validationResult.isSuccess) {
                val violations = validationResult.violations.violationsList
                    .joinToString(\", \") { \"${it.fieldPath}: ${it.message}\" }
                println(\"\"\"
                    {\"success\": false, \"error\": \"Validation failed: $violations\"}
                \"\"\".trimIndent())
                return
            }
            
            // Binary roundtrip
            val binary = proto.toByteArray()
            val originalHash = proto.hashCode()
            
            val deserialized = JonSharedCmd.Root.parseFrom(binary)
            val roundtripHash = deserialized.hashCode()
            
            // Extract back to Transit
            val extracted = GeneratedCommandHandlers.extractCommand(deserialized)
            
            // Convert to JSON for output
            val gson = Gson()
            val jsonPrinter = JsonFormat.printer()
            
            println(\"\"\"
                {
                    \"success\": true,
                    \"original-hash\": $originalHash,
                    \"roundtrip-hash\": $roundtripHash,
                    \"proto\": ${jsonPrinter.print(proto)},
                    \"extracted\": ${gson.toJson(extracted)}
                }
            \"\"\".trimIndent())
            
        } catch (e: Exception) {
            println(\"\"\"
                {\"success\": false, \"error\": \"${e.message?.replace(\"\\\"\", \"\\\\\\\"\")}\"}
            \"\"\".trimIndent())
        }
    }
}")

;; Write the validator if needed
(when-not (.exists (File. "test/kotlin/potatoclient/kotlin/transit/MalliPayloadValidator.kt"))
  (spit "test/kotlin/potatoclient/kotlin/transit/MalliPayloadValidator.kt"
        kotlin-validator-source))
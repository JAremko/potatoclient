package potatoclient.kotlin.transit

import cmd.JonSharedCmd
import com.cognitect.transit.Reader
import com.cognitect.transit.TransitFactory
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.DynamicTest
import org.junit.jupiter.api.TestFactory
import org.junit.jupiter.api.condition.DisabledIfSystemProperty
import potatoclient.kotlin.transit.generated.GeneratedCommandHandlers
import java.io.File
import java.io.FileInputStream

/**
 * Roundtrip tests using test data generated by transit-test-generator tool
 * 
 * To generate test data:
 * cd tools/transit-test-generator
 * ./generate-test-data.sh
 * 
 * This will create Transit and EDN files in test/resources/transit-test-data/
 */
class TransitTestDataRoundtripTest {
    
    companion object {
        private const val TEST_DATA_DIR = "test/resources/transit-test-data"
        private lateinit var testDataDirectory: File
        
        @BeforeAll
        @JvmStatic
        fun checkTestData() {
            testDataDirectory = File(TEST_DATA_DIR)
            if (!testDataDirectory.exists() || !testDataDirectory.isDirectory) {
                println("WARNING: Test data directory not found at $TEST_DATA_DIR")
                println("To generate test data, run: tools/transit-test-generator/generate-test-data.sh")
            }
        }
    }
    
    /**
     * Read Transit MessagePack file and parse as map
     */
    private fun readTransitFile(file: File): Map<String, Any> {
        FileInputStream(file).use { inputStream ->
            val reader: Reader = TransitFactory.reader(TransitFactory.Format.MSGPACK, inputStream)
            @Suppress("UNCHECKED_CAST")
            return reader.read() as Map<String, Any>
        }
    }
    
    /**
     * Read EDN file and parse as map
     * Note: For simplicity, we're using Transit to read EDN since it supports it
     */
    private fun readEdnFile(file: File): Map<String, Any> {
        file.inputStream().use { inputStream ->
            val reader: Reader = TransitFactory.reader(TransitFactory.Format.JSON, inputStream)
            @Suppress("UNCHECKED_CAST")
            return reader.read() as Map<String, Any>
        }
    }
    
    /**
     * Compare two maps recursively, handling numeric type differences
     */
    private fun mapsEqual(expected: Map<*, *>, actual: Map<*, *>): Boolean {
        if (expected.size != actual.size) return false
        
        for ((key, expectedValue) in expected) {
            val actualValue = actual[key] ?: return false
            
            when {
                expectedValue is Map<*, *> && actualValue is Map<*, *> -> {
                    if (!mapsEqual(expectedValue, actualValue)) return false
                }
                expectedValue is Number && actualValue is Number -> {
                    // Handle numeric comparison with tolerance for floating point
                    if (expectedValue is Float || expectedValue is Double ||
                        actualValue is Float || actualValue is Double) {
                        val diff = Math.abs(expectedValue.toDouble() - actualValue.toDouble())
                        if (diff > 0.0001) return false
                    } else {
                        if (expectedValue.toLong() != actualValue.toLong()) return false
                    }
                }
                else -> {
                    if (expectedValue != actualValue) return false
                }
            }
        }
        return true
    }
    
    /**
     * Test a single Transit file roundtrip
     */
    private fun testTransitFileRoundtrip(file: File) {
        println("Testing Transit file: ${file.name}")
        
        // Read original Transit data
        val originalMap = readTransitFile(file)
        println("  Original: $originalMap")
        
        // Convert to protobuf
        val proto = GeneratedCommandHandlers.buildCommand(originalMap)
        assertNotNull(proto, "Failed to build protobuf from Transit map")
        
        // Serialize to binary
        val binary = proto.toByteArray()
        assertTrue(binary.isNotEmpty(), "Protobuf binary should not be empty")
        
        // Deserialize from binary
        val deserializedProto = JonSharedCmd.Root.parseFrom(binary)
        assertNotNull(deserializedProto, "Failed to parse protobuf from binary")
        
        // Convert back to Transit map
        val resultMap = GeneratedCommandHandlers.extractCommand(deserializedProto)
        println("  Result: $resultMap")
        
        // Verify structure matches
        assertEquals(originalMap.keys, resultMap.keys, 
            "Top-level keys should match after roundtrip")
        
        // Deep comparison
        assertTrue(mapsEqual(originalMap, resultMap),
            "Maps should be equal after roundtrip conversion")
    }
    
    /**
     * Test a single EDN file roundtrip
     */
    private fun testEdnFileRoundtrip(file: File) {
        println("Testing EDN file: ${file.name}")
        
        // Read original EDN data
        val originalMap = readEdnFile(file)
        println("  Original: $originalMap")
        
        // Convert to protobuf
        val proto = GeneratedCommandHandlers.buildCommand(originalMap)
        assertNotNull(proto, "Failed to build protobuf from EDN map")
        
        // Serialize to binary
        val binary = proto.toByteArray()
        assertTrue(binary.isNotEmpty(), "Protobuf binary should not be empty")
        
        // Deserialize from binary
        val deserializedProto = JonSharedCmd.Root.parseFrom(binary)
        assertNotNull(deserializedProto, "Failed to parse protobuf from binary")
        
        // Convert back to map
        val resultMap = GeneratedCommandHandlers.extractCommand(deserializedProto)
        println("  Result: $resultMap")
        
        // Verify structure matches
        assertEquals(originalMap.keys, resultMap.keys, 
            "Top-level keys should match after roundtrip")
    }
    
    /**
     * Dynamic test factory that creates a test for each Transit file
     */
    @TestFactory
    @DisabledIfSystemProperty(named = "skip.transit.tests", matches = "true")
    fun transitFileRoundtripTests(): Collection<DynamicTest> {
        if (!testDataDirectory.exists()) {
            println("Skipping Transit file tests - no test data directory")
            return emptyList()
        }
        
        val transitFiles = testDataDirectory.listFiles { file -> 
            file.name.endsWith(".transit") 
        } ?: emptyArray()
        
        if (transitFiles.isEmpty()) {
            println("No Transit test files found in $TEST_DATA_DIR")
            println("Run tools/transit-test-generator/generate-test-data.sh to generate test data")
            return emptyList()
        }
        
        return transitFiles.map { file ->
            DynamicTest.dynamicTest("Roundtrip: ${file.nameWithoutExtension}") {
                testTransitFileRoundtrip(file)
            }
        }
    }
    
    /**
     * Dynamic test factory that creates a test for each EDN file
     */
    @TestFactory
    @DisabledIfSystemProperty(named = "skip.edn.tests", matches = "true")
    fun ednFileRoundtripTests(): Collection<DynamicTest> {
        if (!testDataDirectory.exists()) {
            println("Skipping EDN file tests - no test data directory")
            return emptyList()
        }
        
        val ednFiles = testDataDirectory.listFiles { file -> 
            file.name.endsWith(".edn") 
        } ?: emptyArray()
        
        if (ednFiles.isEmpty()) {
            println("No EDN test files found in $TEST_DATA_DIR")
            println("Run tools/transit-test-generator/generate-test-data.sh to generate test data")
            return emptyList()
        }
        
        return ednFiles.map { file ->
            DynamicTest.dynamicTest("Roundtrip: ${file.nameWithoutExtension}") {
                testEdnFileRoundtrip(file)
            }
        }
    }
    
    /**
     * Test specific edge cases with overridden values
     */
    @Test
    fun `test edge case commands with specific overrides`() {
        val specificTestFiles = listOf(
            "cv_start_track_specific.edn",
            "rotary_goto_specific.edn", 
            "rotary_scan_camelcase.edn"
        )
        
        for (fileName in specificTestFiles) {
            val file = File(testDataDirectory, fileName)
            if (file.exists()) {
                println("\nTesting edge case: $fileName")
                testEdnFileRoundtrip(file)
            } else {
                println("WARNING: Edge case test file not found: $fileName")
            }
        }
    }
    
    /**
     * Verify that protobuf equals() works for roundtrip comparison
     */
    @Test
    fun `test protobuf equals for roundtrip verification`() {
        val testMap = mapOf(
            "cv" to mapOf(
                "start-track-ndc" to mapOf(
                    "channel" to "heat",
                    "x" to 0.5f,
                    "y" to 0.5f
                )
            )
        )
        
        // Build two identical protobufs
        val proto1 = GeneratedCommandHandlers.buildCommand(testMap)
        val proto2 = GeneratedCommandHandlers.buildCommand(testMap)
        
        // They should be equal
        assertEquals(proto1, proto2, "Identical commands should be equal")
        
        // Roundtrip through binary
        val binary = proto1.toByteArray()
        val deserialized = JonSharedCmd.Root.parseFrom(binary)
        
        // Should still be equal after roundtrip
        assertEquals(proto1, deserialized, "Protobuf should be equal after binary roundtrip")
    }
}